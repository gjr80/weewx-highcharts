##errorCatcher Echo
#*
A WeeWX template to generate a JSON data file for yearly observation plots.

Copyright (C) 2016-20 Gary Roderick                 gjroderick<at>gmail.com

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see http://www.gnu.org/licenses/.


Description

This template is part of the Highcharts for WeeWX extension and produces a text
file containing JSON format data for use with Highcharts to plot WeeWX 
observation data over a one year period.


Pre-Requisites

- Highcharts for WeeWX extension
- PyEphem for inclusion of insolation data


Version: 0.4.0                                      Date: xx xxxxx 2021

Revision History
    xx xxxxx 2021       v0.4.0
        - now uses .series tags where possible
    17 March 2021       v0.3.2
        - no change, version number change only
    20 October 2020     v0.3.1
        - no change, version number change only
    20 September 2020   v0.3.0
        - renamed numerous SLE tags
    4 September 2018    v0.2.2
        - reformatted comments
    16 May 2017         v0.2.1
        - no change, version number change only
    4 May 2017          v0.2.0
        - no change, version number change only
    22 November 2016    v0.1.0
        - initial implementation
TODO. Year plots include tomorrow in averages line plots
*#
#import calendar
#import time
#import json
#set $stop_struct = time.localtime($current.dateTime.raw)
#set $utcOffset = (calendar.timegm($stop_struct) - calendar.timegm(time.gmtime(time.mktime($stop_struct)))) / 60
[{
"_version": "year.json.tmpl version 0.4.0",
"utcoffset": $utcOffset, 
"timespan": {"start": $yearPlotStart, "stop": $yearPlotEnd}, 
## Setup temperature plot vectors
#set $min = $last_year.outTemp.series(aggregate_type='min', aggregate_interval='day')
#set $max = $last_year.outTemp.series(aggregate_type='max', aggregate_interval='day')
"temperatureplot": {
"outTempminmax": $jsonize($zip($min.start.unix_epoch_ms.raw, $rnd($min.data.raw, 1), $rnd($max.data.raw, 1))),
"outTempaverage": $last_year.outTemp.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"units": "$unit.label.outTemp"#slurp
#if $varExists('$outTemp_min_range')
, 
"minRange": $outTemp_min_range},
#else
}, 
#end if
## Setup windchill plot vectors
#set $min = $last_year.appTemp.series(aggregate_type='min', aggregate_interval='day')
#set $max = $last_year.appTemp.series(aggregate_type='max', aggregate_interval='day')
"windchillplot": {
"appTempminmax": $jsonize($zip($min.start.unix_epoch_ms.raw, $rnd($min.data.raw, 1), $rnd($max.data.raw, 1))),
"appTempaverage": $last_year.appTemp.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"windchillaverage": $last_year.windchill.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"heatindexaverage": $last_year.heatindex.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"units": "$unit.label.outTemp"#slurp
#if $varExists('$outTemp_min_range')
, 
"minRange": $outTemp_min_range},
#else
}, 
#end if
## Setup humidity plot vectors
#set $min = $last_year.outHumidity.series(aggregate_type='min', aggregate_interval='day')
#set $max = $last_year.outHumidity.series(aggregate_type='max', aggregate_interval='day')
"humidityplot": {
"outHumidityminmax": $jsonize($zip($min.start.unix_epoch_ms.raw, $rnd($min.data.raw, 0), $rnd($max.data.raw, 0))),
"outHumidityaverage": $last_year.outHumidity.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(0).json,
"units": "$unit.label.outHumidity"#slurp
#if $varExists('$outHumidity_min_range')
, 
"minRange": $outHumidity_min_range},
#else
}, 
#end if
## Setup barometer plot vectors
#set $min = $last_year.barometer.series(aggregate_type='min', aggregate_interval='day')
#set $max = $last_year.barometer.series(aggregate_type='max', aggregate_interval='day')
"barometerplot": {
"barometerminmax": $jsonize($zip($min.start.unix_epoch_ms.raw, $rnd($min.data.raw, 1), $rnd($max.data.raw, 1))),
"barometeraverage": $last_year.barometer.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"units": "$unit.label.barometer"#slurp
#if $varExists('$barometer_min_range')
, 
"minRange": $barometer_min_range},
#else
}, 
#end if
"windplot": {
"windmax": $last_year.windGust.series(aggregate_type='max', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"windaverage": $last_year.windvec.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').magnitude.round(1).json,
"windAvmax": $last_year.windSpeed.series(aggregate_type='max', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"windAverage": $last_year.windSpeed.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"units": "$unit.label.windSpeed"#slurp
#if $varExists('$windSpeed_min_range')
, 
"minRange": $windSpeed_min_range},
#else
}, 
#end if
"winddirplot": {"windDir": $last_year.windvec.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').direction.round(0).json,
"units": "$unit.label.windDir"#slurp
#if $varExists('$windDir_min_range')
, 
"minRange": $windDir_min_range},
#else
}, 
#end if
"rainplot": {
"rainsum": $last_year.rain.series(aggregate_type='sum', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"units": "$unit.label.rain"#slurp
#if $varExists('$rain_min_range')
, 
"minRange": $rain_min_range},
#else
}, 
#end if
"radiationplot": {
"radiationmax": $last_year.radiation.series(aggregate_type='max', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(0).json,
"radiationaverage": $last_year.radiation.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(0).json,
"units": "$unit.label.radiation"#slurp
#if $varExists('$radiation_min_range')
, 
"minRange": $radiation_min_range},
#else
}, 
#end if
"uvplot": {
"uvmax": $last_year.UV.series(aggregate_type='max', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"uvaverage": $last_year.UV.series(aggregate_type='avg', aggregate_interval='day', time_series='stop', time_unit='unix_epoch_ms').round(1).json,
"units": "$unit.label.uv"#slurp
#if $varExists('$UV_min_range')
, 
"minRange": $UV_min_range},
#else
}, 
#end if
"windroseMonth": {#slurp
"series": $wrmonth['windrosejson'], 
"xAxis": {"categories": $wrmonth['xAxisCategoriesjson']}, 
"yAxis": $wrmonth['yAxisjson'],
"colors": $wrmonth['coloursjson'], 
"title": {"text": $wrmonth['titlejson']}, 
"legend": {"title": {"text": $wrmonth['legendTitlejson']}},
"bullseye": $wrmonth['bullseyejson']
},
"windroseYear": {#slurp
"series": $wryear['windrosejson'], 
"xAxis": {"categories": $wryear['xAxisCategoriesjson']}, 
"yAxis": $wryear['yAxisjson'],
"colors": $wryear['coloursjson'], 
"title": {"text": $wryear['titlejson']}, 
"legend": {"title": {"text": $wryear['legendTitlejson']}},
"bullseye": $wryear['bullseyejson']
}
}]